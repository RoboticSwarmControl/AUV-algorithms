\pdfobjcompresslevel=0  % I had adobe error 131, and this removed it: http://tex.stackexchange.com/questions/64448/how-to-overcome-acrobat-reader-error-131-with-a-pdflatex-doc

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
\usepackage{calc}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
  colorlinks =true,
  urlcolor = black,
  linkcolor = black
}
\usepackage{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{rotating}
\usepackage{booktabs}

\usepackage{rotating}
\usepackage{nicefrac}
\usepackage{cite}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{overpic}
\graphicspath{{./pictures/}}
\usepackage{breqn} %for breaking equations automatically
\usepackage[ruled]{algorithm}
\usepackage{algpseudocode}
\usepackage{multirow}

\usepackage{bm}   % boldface math type
\usepackage{soul}  % for highlighting
\newcommand{\todo}[1]{\vspace{5 mm}\par \noindent \framebox{\begin{minipage}[c]{0.98 \columnwidth} \ttfamily\flushleft \textcolor{red}{#1}\end{minipage}}\vspace{5 mm}\par}
% uncomment this to hide all red todos
%\renewcommand{\todo}{}

%% ABBREVIATIONS
\newcommand{\qstart}{q_{\text{start}}}
\newcommand{\qgoal}{q_{\text{goal}}}
\newcommand{\pstart}{p_{\text{start}}}
\newcommand{\pgoal}{p_{\text{goal}}}
\newcommand{\xstart}{x_{\text{start}}}
\newcommand{\xgoal}{x_{\text{goal}}}
\newcommand{\ystart}{y_{\text{start}}}
\newcommand{\ygoal}{y_{\text{goal}}}
\newcommand{\gammastart}{\gamma_{\text{start}}}
\newcommand{\gammagoal}{\gamma_{\text{goal}}}
\providecommand{\proc}[1]{\textsc{#1}}


\newcommand{\ARLfull}{Aero\-space Ro\-bot\-ics La\-bora\-tory }
\newcommand{\ARL}{\textsc{arl}}
\newcommand{\JPL}{\textsc{jpl}}
\newcommand{\PRM}{\textsc{prm}}
\newcommand{\CM}{\textsc{cm}}
\newcommand{\SVM}{\textsc{svm}}
\newcommand{\NN}{\textsc{nn}}
\newcommand{\prm}{\textsc{prm}}
\newcommand{\lemur}{\textsc{lemur}}
\newcommand{\Lemur}{\textsc{Lemur}}
\newcommand{\LP}{\textsc{lp}} 
\newcommand{\SOCP}{\textsc{socp}}
\newcommand{\SDP}{\textsc{sdp}}
\newcommand{\NP}{\textsc{np}}
\newcommand{\SAT}{\textsc{sat}}
\newcommand{\LMI}{\textsc{lmi}}
\newcommand{\hrp}{\textsc{hrp\nobreakdash-2}}
\newcommand{\DOF}{\textsc{dof}}
\newcommand{\UIUC}{\textsc{uiuc}}
%% MACROS


\providecommand{\abs}[1]{\left\lvert#1\right\rvert}
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\normn}[2]{\left\lVert#1\right\rVert_#2}
\providecommand{\dualnorm}[1]{\norm{#1}_\ast}
\providecommand{\dualnormn}[2]{\norm{#1}_{#2\ast}}
\providecommand{\set}[1]{\lbrace\,#1\,\rbrace}
\providecommand{\cset}[2]{\lbrace\,{#1}\nobreak\mid\nobreak{#2}\,\rbrace}
\providecommand{\lscal}{<}
\providecommand{\gscal}{>}
\providecommand{\lvect}{\prec}
\providecommand{\gvect}{\succ}
\providecommand{\leqscal}{\leq}
\providecommand{\geqscal}{\geq}
\providecommand{\leqvect}{\preceq}
\providecommand{\geqvect}{\succeq}
\providecommand{\onevect}{\mathbf{1}}
\providecommand{\zerovect}{\mathbf{0}}
\providecommand{\field}[1]{\mathbb{#1}}
\providecommand{\C}{\field{C}}
\providecommand{\R}{\field{R}}
\newcommand{\Cspace}{\mathcal{Q}}
\newcommand{\Uspace}{\mathcal{U}}
\providecommand{\Fspace}{\Cspace_\text{free}}
\providecommand{\Hcal}{$\mathcal{H}$}
\providecommand{\Vcal}{$\mathcal{V}$}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\cone}{cone}
\DeclareMathOperator{\homog}{homog}
\DeclareMathOperator{\domain}{dom}
\DeclareMathOperator{\range}{range}
\DeclareMathOperator{\sign}{sgn}
\DeclareMathOperator{\sgn}{signum}
\providecommand{\polar}{\triangle}
\providecommand{\ainner}{\underline{a}}
\providecommand{\aouter}{\overline{a}}
\providecommand{\binner}{\underline{b}}
\providecommand{\bouter}{\overline{b}}
\newcommand{\D}{\nobreakdash-\textsc{d}}
%\newcommand{\Fspace}{\mathcal{F}}
\providecommand{\Fspace}{\Cspace_\text{free}}
\providecommand{\free}{\text{\{}\mathsf{free}\text{\}}}
\providecommand{\iff}{\Leftrightarrow}
\providecommand{\subinner}[1]{#1_{\text{inner}}}
\providecommand{\subouter}[1]{#1_{\text{outer}}}
\providecommand{\Ppoly}{\mathcal{X}}
\providecommand{\Pproj}{\mathcal{Y}}
\providecommand{\Pinner}{\subinner{\Pproj}}
\providecommand{\Pouter}{\subouter{\Pproj}}
\DeclareMathOperator{\argmax}{arg\,max}
\providecommand{\Aineq}{B}
\providecommand{\Aeq}{A}
\providecommand{\bineq}{u}
\providecommand{\beq}{t}
\DeclareMathOperator{\area}{area}
\newcommand{\contact}[1]{\Cspace_{#1}}
\newcommand{\feasible}[1]{\Fspace_{#1}}
\newcommand{\dd}{\; \mathrm{d}}
\newcommand{\figwid}{0.22\columnwidth}

\DeclareMathOperator{\atan2}{atan2}


\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\begin{document}

%%%%%%%%%%%%%% For debugging purposes, I like to display the TOC
%\tableofcontents
%\setcounter{tocdepth}{3}
%\newpage
%\mbox{}
%\newpage
%\mbox{}
%\newpage
%%%%%% END TOC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\LARGE \bf 
Optimal trajectory determination of a single USV for Underwater Sensors Localization based on Range-Free Scheme
}
\author{
Haoran Zhao
Aaron T. Becker
\thanks{{
      \protect\url{s.fekete@tu-bs.de},
H. Zhao and A.~Becker are with the  Dept.~of Electrical and Computer Engineering,  University of Houston, Houston, TX 70004, USA {\tt\small atbecker@uh.edu}.
}
} %\end thanks
} % end author block
\maketitle



\begin{abstract} 
Many applications of underwater wireless sensor network require the sensor location. The main idea in most localization algorithm has been that localizing the unknown sensor nodes location with the help of landmarks with know coordinates (e.g GPS equipped beacons). A promising method to reduce the cost of localization process is to replace bunch of GPS equipped beacons with one mobile beacon. In this case, considering the coverage, time, accuracy and energy cost, path planning of mobile beacon becomes the fundamental research issue. 

This paper presents a strategy called "compass" for optimizing trajectory of a moving Unmanned Surface Vehicle (USV) to complete localization. The present strategy involves three major components: a) underwater localization algorithm based on centralized Range-Free scheme and Monte Carlo Localization algorithm. b) calculation of an expected information density (EID) map based on prior information. c) R-search mode based on pseudo formation. The "compass" strategy does not rely on high accuracy sensing model, and is well-posed  for coverage, time and cost. We  successfully simulate localization for targets in two-dimensional work-space using directional sensor under different conditions, and compare performance to traditional trajectories.   
\end{abstract}


%\textcolor{red}{In general pay more attention to structuring each paragraph so that you guide your reader by telling them first what you will accomplish in that paragraph and then making sure you support all your assertions.}

%###############################################################
\section{Introduction}
%###############################################################

Underwater wireless sensor network (UWSN) is an emerging research area that benefits ocean environmental monitoring, offshore exploration, military surveillance, {\em etc} ~\cite{Underwater acoustic sensor networks: Research challenges}. It is now more common for oil and gas companies, fishing industry, militaries, and marine researchers to deploy underwater wireless sensor network to obtain submarine data. However, the fundamental problem is how to efficiently complete underwater localization.

currently, many underwater localization algorithms have been proposed, and they can be classified into three categories~\cite{Localization techniques for underwater acoustic sensor networks.}: (1) In stationary localization algorithms, all sensors have fixed locations. (2) In mobile localization algorithms, all sensors are mobile. (3) In hybrid localization algorithms, fixed and mobile sensors are coexist. these three categories can be further compared and summarized into subcategories presented in~\cite{Localization Algorithms of UnderwaterWireless Sensor Networks: A Survey}, using following aspects:
\begin{enumerate}
\item range method:  Range-based schemes and range-free schemes
\item time synchronization: Time synchronization is an important role in range-based schemes. in underwater localization environment, it is difficult to achieve precise time synchronization. Thus, in some localization algorithm based on range-based schemes, whole processes are assumed to be perfect time synchronization.
\item localization coverage: Maximizing exploration coverage is a fundamental requirement for underwater localization  algorithm. one goal of localization is to balance  coverage and cost.
\item localization time: In any localization algorithm, localization time can not be too long. especially in UWSN, sensors can be passively drifted by currents. The localization accuracy will decrease with increasing of time.
\item localization accuracy: Localization accuracy is the most important evaluation criterion. A good localization 
algorithm or path planning is aim to achieve high localization accuracy.
\item energy consumption: energy consumption can be considered into two parts. firstly, mobile beacon consumption, which means electricity, fuel, {\em etc}. secondly, wireless sensor consumption.    
\end{enumerate}
considering above aspects, accurate time synchronization in real-time will introduces more energy consumption and
hardware cost. and the range-based schemes uses ToA (Time of Arrival) and TDoA (Time Difference of Arrival). thus, the accuracy of time synchronization will significantly influence the localization results.additional, unlike the speed of light propagation in air is constant, acoustic speed propagates in water varies with temperature, salinity and water pressure, which is a nonlinear speed model ~\cite{Principles of underwater sound for engineers,}.  considering these reasons, we use range-free schemes to avoid time synchronization and reduce hardware cost. because computation complexity will also influence the energy consumption, we transfer 3D work space into 2D work space by simply equipping a pressure sensor to obtain depth data ~\cite{Localization algorithms of underwater wireless sensor networks: A survey} to reduce the computation complexity. also, all computation is centralized, which occur on the USV. the "compass" strategy is inspired by ~\cite{Trajectory Optimization for Continuous Ergodic Exploration}~\cite{Optimal Planning for Target Localization and Coverage Using Range Sensing}. the main idea of "compass" strategy is to use prior information to construct  EID map map into 360 degree, which is similar as compass. compass will instruct USV the orientation to trade off coverage and cost. after result accuracy achieve specific level, USV enters R-search mode, which is inspired by ~cite{Optimal trajectory determination of a single moving beacon for efficient localization in a mobile ad-hoc network}, to refine localization results. 

this paper is organized as follows: In Section 2, we discuss the related work of optimizing trajectory algorithm of underwater localization with mobile beacons. Section 3 presents the localization algorithm for a single USV. Section 4 presents the EID algorithm, coverage problem. and pseudo formation.we discuss how "compass" strategy works to optimizing the trajectory of USV in Section 5. Section 6 shows the simulation results under different conditions compare with traditional strategy. In Section 7. we conclude with discussion on performance and future work.

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{TetrisOne.jpg}%\put(30,-7){ $m=1$, partition 1}
\end{overpic}
\caption{\label{fig:prototype}
Gravity-fed hardware implementation of  particle computation.  The reconfigurable prototype is setup as a {\sc fan-out} gate using a 2$\times$1 robot (white). This paper proves that such a gate is impossible using only 1$\times$1 robots.  }
\vspace{-1em}
\end{figure}

 \subsection{Model}
  
This paper builds on the techniques for controlling many simple robots with uniform control inputs presented in \cite{Becker2013f,Becker2014,Becker2014a}, using the following rules:
\begin{enumerate}
\item A planar  grid \emph{workspace} $W$ is filled with a number of unit-square robots (each occupying one cell of the grid)  and some fixed unit-square blocks.  Each unit square in the workspace is either  \emph{free}, which a robot may occupy or \emph{obstacle} which a robot may not occupy.  Each square in the grid can be referenced by its Cartesian coordinates $\bm{x}=(x,y)$.
\item All robots are commanded in unison: the valid commands are  ``Go Up" ($u$), ``Go Right" ($r$), ``Go Down" ($d$), or ``Go Left" ($l$).  
\item Robots all move in the commanded direction until they 
	\begin{enumerate}
		\item hit an obstacle 
		\item hit a stationary robot. 
		\item share an edge with a compatible robot
	\end{enumerate}
	If a robot shares an edge with a compatible robot the two robots bond and from then on move as a unit.
A \emph{command sequence} $\bm{m}$ consists of an ordered sequence of moves $m_k$, where each $m_k\in\{u,d,r,l\}$  A representative command sequence is $\langle u,r,d,l,d,r,u,\ldots\rangle$. We assume the area of $W$ is finite and issue each command long enough for the robots to reach their maximum extent.
\end{enumerate}



%###############################################################
\section{Related Work}\label{sec:RelatedWork}
%###############################################################
Our efforts have similarities with \emph{mechanical computers},  computers
constructed from mechanical, not electrical components. For a fascinating
nontechnical review, see \cite{McCourtney1999}.  These devices have a rich
history, from the \emph{Pascaline}, an adding machine invented in 1642 by a
nineteen-year old Blaise Pascal; Herman Hollerith's punch-card tabulator in
1890; to the mechanical devices of IBM culminating in the 1940s.  These devices
used precision gears, pulleys, or electric motors to carry out calculations.
Though our {\sc Grid-World} implementations are rather basic, 
we require none of these precision elements---merely unit-size obstacles,  and
sliding particles sized 2$\times$1 and 1$\times$1 for achieving computational universality.
%Can we call these robots? Indeed, the ENIAC itself was labelled a robot by the
%associated press when it was announced in the 1940s. 

\subsection{Collision-Based Computing}
Collision-based computing has been defined as \emph{``computation in a structureless medium populated with mobile objects''}.  For a survey of this area, see the excellent collection~\cite{Adamatzky2012}. Early examples include the billiard-ball computer proposed by Fredkin and Toffoli using only spherical balls and a frictionless environment composed of elastic collisions with other balls and with angled walls \cite{Fredkin1982ConservativeLogic}. Another popular example is Conway's {\em Game of Life}, a cellular automaton governed by four simple rules~\cite{berlekamp2001winning}. Cells live or die based on the number of neighbors. These rules have been examined in depth and used to design a Turing-complete computer \cite{Adamatzky2002}.  Game of life scenarios and billiard-ball computers are fascinating, but lack a physical implementation.  In this paper we present a collision-based system for computation and provide a physical implementation.
%\textcolor{red}{Todo: this paragraph is incomplete}


\subsection{Sliding-Block Puzzles}
Sliding-block puzzles use rectangular tiles that are constrained to move in a 2D workspace. The objective is to move one or more tiles to desired locations. They have a long history.
Hearn \cite{hearn2005complexity} and Demaine \cite{Demaine2009} showed tiles can be arranged to create logic gates, and used this technique to prove {\sc pspace} complexity for a variety of sliding-block puzzles.  Hearn expressed the idea of building computers from the sliding blocks---many of the logic gates could be connected together, and the user could propagate a signal from one gate to the next by sliding intermediate tiles.  This requires the user to know precisely which sequence of gates to enable/disable.  In contrast to such a hands-on approach, with our architecture we can build circuits, store parameters in memory, and then actuate the entire system in parallel using a global control signal.

\subsection{Other Related Work on Programmable Matter}
Clearly there is a wide range of interesting scenarios for developing approaches to programmable matter.
One such model is the \emph{abstract Tile-Assembly Model} (aTAM) by Winfree~\cite{Winf98,WLWS98,LaWiRe99}, which has 
sparked a wide range of theoretical and practical research. In this model, unit-sized pixels (``tiles'')
interact and bond with the help of differently labeled edges, eventually composing complex assemblies.
Even though the operations and final objectives in this model are quite different from our particle computation with global
inputs (e.g., key features of the aTAM are that tiles can have a wide range of different edge types, and
that they keep sticking together after bonding), there is
a remarkable geometric parallelism to a key result of our present paper:
While it is widely believed that at the most basic level of interaction (called {\em temperature 1}),
computational universality {\em cannot be achieved}~\cite{LSAT1,ManuchTemp1,IUNeedsCoop} in the aTAM with only unit-sized pixels, 
very recent work~\cite{fhp+-ucapt-15} shows that computational universality {\em can be achieved} as soon as even slightly bigger tiles are used. 
This resembles the results of our paper, which shows that unit-size particles are insufficient for universal computation, while employing bigger particles suffices




%###############################################################
\section{Conclusion}\label{sec:Conclusion}
%###############################################################
In this paper we 

This work, along with \cite{Becker2013f,Becker2014,Becker2014a}, introduces a
new model for additive assembly.  Interesting applications will aim at 
nanoscale and microfluidics work.

    
%\section{Acknowledgements}
%This work was supported by the National Science Foundation under
%\href{http://nsf.gov/awardsearch/showAward?AWD_ID=1208509}{NRI-1208509}.  
   
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../../RoboticSwarmControlLab/bib/aaronrefs}%,../aaronrefs} %../../../../../../ensemble/bib/aaronrefs}


\end{document}


